// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"server/internal/core/model/entity"
)

func newArticleCategory(db *gorm.DB, opts ...gen.DOOption) articleCategory {
	_articleCategory := articleCategory{}

	_articleCategory.articleCategoryDo.UseDB(db, opts...)
	_articleCategory.articleCategoryDo.UseModel(&entity.ArticleCategory{})

	tableName := _articleCategory.articleCategoryDo.TableName()
	_articleCategory.ALL = field.NewAsterisk(tableName)
	_articleCategory.ID = field.NewUint(tableName, "id")
	_articleCategory.CreatedAt = field.NewTime(tableName, "created_at")
	_articleCategory.UpdatedAt = field.NewTime(tableName, "updated_at")
	_articleCategory.DeletedAt = field.NewField(tableName, "deleted_at")
	_articleCategory.ParentID = field.NewUint(tableName, "parent_id")
	_articleCategory.Title = field.NewString(tableName, "title")
	_articleCategory.ImageURL = field.NewField(tableName, "image_url")
	_articleCategory.Keywords = field.NewString(tableName, "keywords")
	_articleCategory.Description = field.NewString(tableName, "description")
	_articleCategory.Sort = field.NewInt32(tableName, "sort")

	_articleCategory.fillFieldMap()

	return _articleCategory
}

// articleCategory 文章分类
type articleCategory struct {
	articleCategoryDo articleCategoryDo

	ALL         field.Asterisk
	ID          field.Uint // 文章分类id
	CreatedAt   field.Time
	UpdatedAt   field.Time
	DeletedAt   field.Field
	ParentID    field.Uint   // 父级ID
	Title       field.String // 文章分类标题
	ImageURL    field.Field  // 文章分类图片
	Keywords    field.String // SEO关键词
	Description field.String // SEO描述
	Sort        field.Int32  // 排序

	fieldMap map[string]field.Expr
}

func (a articleCategory) Table(newTableName string) *articleCategory {
	a.articleCategoryDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a articleCategory) As(alias string) *articleCategory {
	a.articleCategoryDo.DO = *(a.articleCategoryDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *articleCategory) updateTableName(table string) *articleCategory {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewUint(table, "id")
	a.CreatedAt = field.NewTime(table, "created_at")
	a.UpdatedAt = field.NewTime(table, "updated_at")
	a.DeletedAt = field.NewField(table, "deleted_at")
	a.ParentID = field.NewUint(table, "parent_id")
	a.Title = field.NewString(table, "title")
	a.ImageURL = field.NewField(table, "image_url")
	a.Keywords = field.NewString(table, "keywords")
	a.Description = field.NewString(table, "description")
	a.Sort = field.NewInt32(table, "sort")

	a.fillFieldMap()

	return a
}

func (a *articleCategory) WithContext(ctx context.Context) IArticleCategoryDo {
	return a.articleCategoryDo.WithContext(ctx)
}

func (a articleCategory) TableName() string { return a.articleCategoryDo.TableName() }

func (a articleCategory) Alias() string { return a.articleCategoryDo.Alias() }

func (a articleCategory) Columns(cols ...field.Expr) gen.Columns {
	return a.articleCategoryDo.Columns(cols...)
}

func (a *articleCategory) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *articleCategory) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 10)
	a.fieldMap["id"] = a.ID
	a.fieldMap["created_at"] = a.CreatedAt
	a.fieldMap["updated_at"] = a.UpdatedAt
	a.fieldMap["deleted_at"] = a.DeletedAt
	a.fieldMap["parent_id"] = a.ParentID
	a.fieldMap["title"] = a.Title
	a.fieldMap["image_url"] = a.ImageURL
	a.fieldMap["keywords"] = a.Keywords
	a.fieldMap["description"] = a.Description
	a.fieldMap["sort"] = a.Sort
}

func (a articleCategory) clone(db *gorm.DB) articleCategory {
	a.articleCategoryDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a articleCategory) replaceDB(db *gorm.DB) articleCategory {
	a.articleCategoryDo.ReplaceDB(db)
	return a
}

type articleCategoryDo struct{ gen.DO }

type IArticleCategoryDo interface {
	gen.SubQuery
	Debug() IArticleCategoryDo
	WithContext(ctx context.Context) IArticleCategoryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IArticleCategoryDo
	WriteDB() IArticleCategoryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IArticleCategoryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IArticleCategoryDo
	Not(conds ...gen.Condition) IArticleCategoryDo
	Or(conds ...gen.Condition) IArticleCategoryDo
	Select(conds ...field.Expr) IArticleCategoryDo
	Where(conds ...gen.Condition) IArticleCategoryDo
	Order(conds ...field.Expr) IArticleCategoryDo
	Distinct(cols ...field.Expr) IArticleCategoryDo
	Omit(cols ...field.Expr) IArticleCategoryDo
	Join(table schema.Tabler, on ...field.Expr) IArticleCategoryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IArticleCategoryDo
	RightJoin(table schema.Tabler, on ...field.Expr) IArticleCategoryDo
	Group(cols ...field.Expr) IArticleCategoryDo
	Having(conds ...gen.Condition) IArticleCategoryDo
	Limit(limit int) IArticleCategoryDo
	Offset(offset int) IArticleCategoryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IArticleCategoryDo
	Unscoped() IArticleCategoryDo
	Create(values ...*entity.ArticleCategory) error
	CreateInBatches(values []*entity.ArticleCategory, batchSize int) error
	Save(values ...*entity.ArticleCategory) error
	First() (*entity.ArticleCategory, error)
	Take() (*entity.ArticleCategory, error)
	Last() (*entity.ArticleCategory, error)
	Find() ([]*entity.ArticleCategory, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.ArticleCategory, err error)
	FindInBatches(result *[]*entity.ArticleCategory, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*entity.ArticleCategory) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IArticleCategoryDo
	Assign(attrs ...field.AssignExpr) IArticleCategoryDo
	Joins(fields ...field.RelationField) IArticleCategoryDo
	Preload(fields ...field.RelationField) IArticleCategoryDo
	FirstOrInit() (*entity.ArticleCategory, error)
	FirstOrCreate() (*entity.ArticleCategory, error)
	FindByPage(offset int, limit int) (result []*entity.ArticleCategory, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IArticleCategoryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a articleCategoryDo) Debug() IArticleCategoryDo {
	return a.withDO(a.DO.Debug())
}

func (a articleCategoryDo) WithContext(ctx context.Context) IArticleCategoryDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a articleCategoryDo) ReadDB() IArticleCategoryDo {
	return a.Clauses(dbresolver.Read)
}

func (a articleCategoryDo) WriteDB() IArticleCategoryDo {
	return a.Clauses(dbresolver.Write)
}

func (a articleCategoryDo) Session(config *gorm.Session) IArticleCategoryDo {
	return a.withDO(a.DO.Session(config))
}

func (a articleCategoryDo) Clauses(conds ...clause.Expression) IArticleCategoryDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a articleCategoryDo) Returning(value interface{}, columns ...string) IArticleCategoryDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a articleCategoryDo) Not(conds ...gen.Condition) IArticleCategoryDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a articleCategoryDo) Or(conds ...gen.Condition) IArticleCategoryDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a articleCategoryDo) Select(conds ...field.Expr) IArticleCategoryDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a articleCategoryDo) Where(conds ...gen.Condition) IArticleCategoryDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a articleCategoryDo) Order(conds ...field.Expr) IArticleCategoryDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a articleCategoryDo) Distinct(cols ...field.Expr) IArticleCategoryDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a articleCategoryDo) Omit(cols ...field.Expr) IArticleCategoryDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a articleCategoryDo) Join(table schema.Tabler, on ...field.Expr) IArticleCategoryDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a articleCategoryDo) LeftJoin(table schema.Tabler, on ...field.Expr) IArticleCategoryDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a articleCategoryDo) RightJoin(table schema.Tabler, on ...field.Expr) IArticleCategoryDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a articleCategoryDo) Group(cols ...field.Expr) IArticleCategoryDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a articleCategoryDo) Having(conds ...gen.Condition) IArticleCategoryDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a articleCategoryDo) Limit(limit int) IArticleCategoryDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a articleCategoryDo) Offset(offset int) IArticleCategoryDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a articleCategoryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IArticleCategoryDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a articleCategoryDo) Unscoped() IArticleCategoryDo {
	return a.withDO(a.DO.Unscoped())
}

func (a articleCategoryDo) Create(values ...*entity.ArticleCategory) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a articleCategoryDo) CreateInBatches(values []*entity.ArticleCategory, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a articleCategoryDo) Save(values ...*entity.ArticleCategory) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a articleCategoryDo) First() (*entity.ArticleCategory, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ArticleCategory), nil
	}
}

func (a articleCategoryDo) Take() (*entity.ArticleCategory, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ArticleCategory), nil
	}
}

func (a articleCategoryDo) Last() (*entity.ArticleCategory, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ArticleCategory), nil
	}
}

func (a articleCategoryDo) Find() ([]*entity.ArticleCategory, error) {
	result, err := a.DO.Find()
	return result.([]*entity.ArticleCategory), err
}

func (a articleCategoryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.ArticleCategory, err error) {
	buf := make([]*entity.ArticleCategory, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a articleCategoryDo) FindInBatches(result *[]*entity.ArticleCategory, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a articleCategoryDo) Attrs(attrs ...field.AssignExpr) IArticleCategoryDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a articleCategoryDo) Assign(attrs ...field.AssignExpr) IArticleCategoryDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a articleCategoryDo) Joins(fields ...field.RelationField) IArticleCategoryDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a articleCategoryDo) Preload(fields ...field.RelationField) IArticleCategoryDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a articleCategoryDo) FirstOrInit() (*entity.ArticleCategory, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ArticleCategory), nil
	}
}

func (a articleCategoryDo) FirstOrCreate() (*entity.ArticleCategory, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*entity.ArticleCategory), nil
	}
}

func (a articleCategoryDo) FindByPage(offset int, limit int) (result []*entity.ArticleCategory, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a articleCategoryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a articleCategoryDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a articleCategoryDo) Delete(models ...*entity.ArticleCategory) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *articleCategoryDo) withDO(do gen.Dao) *articleCategoryDo {
	a.DO = *do.(*gen.DO)
	return a
}
